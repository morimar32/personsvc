package graph

// // This file will be automatically regenerated based on the schema, any resolver implementations
// // will be copied through when generating and any unknown code will be moved to the end.
// // Code generated by github.com/99designs/gqlgen version v0.17.30

// import (
// 	"context"
// 	"fmt"
// 	"personsvc/graph/model"

// 	"github.com/golang/protobuf/ptypes/empty"
// 	"github.com/grpc-ecosystem/grpc-gateway/runtime"
// 	"google.golang.org/grpc"
// )

// // AddPerson is the resolver for the AddPerson field.
// func (r *mutationResolver) AddPerson(ctx context.Context, input model.AddPersonRequest) (*model.Person, error) {
// 	panic(fmt.Errorf("not implemented: AddPerson - AddPerson"))
// }

// // Persons is the resolver for the persons field.
// func (r *queryResolver) Persons(ctx context.Context) ([]*model.Person, error) {
// 	var protoReq empty.Empty
// 	var metadata runtime.ServerMetadata
// 	cap := r.QueryCount.Add(-2)
// 	if cap <= 0 {
// 		return nil, nil
// 	}
// 	msg, err := r.Client.GetPersons(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
// 	if err != nil {
// 		return nil, err
// 	}
// 	if msg == nil || msg.Persons == nil || len(msg.Persons) <= 0 {
// 		return nil, nil
// 	}
// 	r.persons = make([]*model.Person, len(msg.Persons))
// 	for i, item := range msg.Persons {
// 		val := &model.Person{
// 			ID:              item.Id,
// 			FirstName:       item.FirstName,
// 			LastName:        item.LastName,
// 			CreatedDateTime: item.Created.AsTime().String(),
// 		}
// 		if item.MiddleName.ProtoReflect().IsValid() {
// 			val.MiddleName = &item.MiddleName.Value
// 		}
// 		if item.Suffix.ProtoReflect().IsValid() {
// 			val.Suffix = &item.Suffix.Value
// 		}
// 		r.persons[i] = val
// 	}
// 	return r.persons, nil
// }

// // Mutation returns MutationResolver implementation.
// func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// // Query returns QueryResolver implementation.
// func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// type mutationResolver struct{ *Resolver }
// type queryResolver struct{ *Resolver }
